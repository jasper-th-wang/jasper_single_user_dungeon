"""
This module contains functions related to the game board.
"""

import random

import narrative.dialogue
from game_utils import render_text


def get_board_dimensions(board: dict) -> tuple:
    """
    Get the dimensions of the board.

    :param board: A dictionary representing the board.
    :precondition: board must be a dictionary, and cannot be empty.
    :precondition: board keys must be coordinate tuples.
    :postcondition: returns a tuple representing the dimensions of the board.
    :raises ValueError: If the board is not a dictionary, or is empty, or if the board keys are not coordinate tuples.
    :return: A tuple representing the dimensions of the board.
    >>> get_board_dimensions({(0, 0): 'some scene', (1, 1): 'O', (2, 2): 'some scene'})
    (2, 2)
    >>> get_board_dimensions({(0, 0): 'some scene', (1, 2): 'O', (2, 3): 'some scene'})
    (2, 3)
    >>> get_board_dimensions({})
    Traceback (most recent call last):
    ...
    ValueError: Invalid input: board cannot be empty
    """
    if not isinstance(board, dict):
        raise ValueError("Invalid input: board must be a dictionary")
    if not board:
        raise ValueError("Invalid input: board cannot be empty")
    if not any(isinstance(coord, tuple) and len(coord) == 2 for coord in board):
        raise ValueError("Invalid input: board keys must be coordinate tuples")
    max_x_coordinate = max(coord[0] for coord in board)
    max_y_coordinate = max(coord[1] for coord in board)
    return max_x_coordinate, max_y_coordinate


def render_ascii_map(board: dict, character_coordinates: tuple) -> None:
    """
    Renders an ASCII map of the game board.

    :param board: A dictionary where the keys are (x, y) tuples representing coordinates.
    :param character_coordinates: A tuple representing the player's current coordinates.
    :precondition: board must be a dictionary, and cannot be empty.
    :precondition: character_coordinates must be a tuple of length 2 representing the player's current coordinates.
    :postcondition: prints an ASCII representation of the game board.
    >>> board = {(0, 0): 'some scene', (1, 0): 'some scene', (0, 1): {}, (1, 1): 'some scene'}
    >>> character_coordinates = (1, 0)
    >>> render_ascii_map(board, character_coordinates)
    +---+---+
    |     @ |
    | !     |
    +---+---+
    >>> board = {(0, 0): 'some scene', (1, 0): {}, (0, 1): 'some scene', (1, 1): 'some scene'}
    >>> character_coordinates = (0, 0)
    >>> render_ascii_map(board, character_coordinates)
    +---+---+
    | @   ! |
    |       |
    +---+---+
    """

    max_x_coordinate, max_y_coordinate = get_board_dimensions(board)

    horizontal_border = "+" + ("---+" * (max_x_coordinate + 1))
    print(horizontal_border)  # Top border of each cell
    for y in range(max_y_coordinate + 1):
        for x in range(max_x_coordinate + 1):
            print("|" if x == 0 else " ", end="")
            # ! indicates npc location, @ indicates player location, if neither is present, print blank space
            grid_symbol = (
                "!"
                if isinstance(board[(x, y)], dict)
                else "@"
                if (x, y) == character_coordinates
                else " "
            )
            print(f" {grid_symbol} ", end="")
        print("|")  # Right border of the last cell
    print(horizontal_border)  # Bottom border of the last row


def render_current_location(board: dict, character: dict) -> None:
    """
    Describe the current location by printing it on the screen

    :param board: a test_game board
    :param character: a test_game character
    :precondition: board is a test_game board generated by the make_board() function in this module
    :precondition: character is a test_game character generated by the make_character() function in this module
    :postcondition: a message is printed, no data is modified and no value is returned
    """
    character_coordinates = (character["X-coordinate"], character["Y-coordinate"])
    scenario = board[character_coordinates]

    if isinstance(scenario, dict):
        play_dialogues_if_scenario_is_npc(scenario, character)
        board[character_coordinates] = (
            "The air is thick with the lingering essence of someone who was here, leaving "
            "behind a haunting, palpable absence."
        )
        scenario = board[character_coordinates]

    if character["Quest"] == "Complete":
        return

    render_ascii_map(board, character_coordinates)
    render_text.print_text_line(scenario)


def make_board(level_info: dict) -> dict:
    """
    Generates a game board based on the provided level information.

    :param level_info: A dictionary containing information about the level extracted from a level JSON file.
    :return: A dictionary representing the game board.
    :precondition: level_info must be a dictionary that has the keys "rows", "columns", "area_descriptions", and "npcs".
    :postcondition: The returned dictionary represents a game board where each cell is either an empty space with a random description, or an NPC.
    :raises ValueError: If level_info is not a dictionary, or if it does not have the keys "rows", "columns", "area_descriptions", and "npcs".
    """
    if not isinstance(level_info, dict):
        raise ValueError("Invalid input: level_info must be a dictionary")
    if not all(
        key in level_info for key in ["rows", "columns", "area_descriptions", "npcs"]
    ):
        raise ValueError(
            "Invalid input: level_info must have the keys 'rows', 'columns', 'area_descriptions', and 'npcs'"
        )

    rows = level_info["rows"]
    columns = level_info["columns"]
    scenarios = level_info["area_descriptions"]
    all_npcs_in_level = level_info["npcs"]

    board = {
        (col, row): scenarios[random.randint(0, len(scenarios) - 1)]
        for col in range(columns)
        for row in range(rows)
    } | {tuple(each_npc["coordinates"]): each_npc for each_npc in all_npcs_in_level}
    return board


def validate_move(rows: int, columns: int, character: dict, direction: str) -> bool:
    """
    Determine whether a move is valid based on whether the move will put the character out of bounds

    :param rows: number of rows on the board
    :param columns: number of columns on the board
    :param character: a game character
    :param direction: a string representing a direction ("W", "S", "D", "A")
    :precondition: rows is a positive integer larger or equal to 2
    :precondition: columns is a positive integer larger or equal to 2
    :precondition: character is a character generated by the make_character(), character is alive, goal is not reached
    :precondition: direction is one of the strings "W", "S", "D", "A"
    :return: a Boolean value of True if character's move is valid, False if it puts character out of bounds
    >>> validate_move(3, 3, {"X-coordinate": 2, "Y-coordinate": 0, "Essence": 3}, "W")
    False
    >>> validate_move(3, 3, {"X-coordinate": 2, "Y-coordinate": 0, "Essence": 3}, "S")
    True
    """
    direction_map = {
        "W": (0, -1),
        "S": (0, 1),
        "D": (1, 0),
        "A": (-1, 0),
    }
    dx, dy = direction_map[direction]
    x, y = character["X-coordinate"] + dx, character["Y-coordinate"] + dy

    return 0 <= x < columns and 0 <= y < rows


def play_dialogues_if_scenario_is_npc(scenario: dict, character: dict) -> None:
    """
    Plays dialogues from a file if the provided scenario is an NPC.

    :param scenario: A dictionary representing an npc.
    :param character: A dictionary representing the game character.
    :precondition: scenario must be a dictionary.
    :precondition: If scenario is a dictionary, it must have a "dialogue_file_path" key that is a string.
    :precondition: character must be a dictionary representing the game character.
    :postcondition: the dialogues from the file specified by "dialogue_file_path" are played.
    :raises KeyError: If scenario is a dictionary, but does not have a "dialogue_file_path" key.
    """
    if "dialogue_file_path" not in scenario:
        raise KeyError("Invalid input: npc must have a dialogue file path")
    narrative.dialogue.play_dialogues_from_file_path(
        scenario["dialogue_file_path"], character
    )
