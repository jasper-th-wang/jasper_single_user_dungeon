"""
ADD A DOCSTRING
"""
import random

from dialogue import render_dialogue
from gameplay import render_text


def get_board_dimensions(board):
    max_x_coordinate = max(coord[0] for coord in board.keys())
    max_y_coordinate = max(coord[1] for coord in board.keys())
    return max_x_coordinate, max_y_coordinate


def render_ascii_map(board, character_coordinates):
    max_x_coordinate, max_y_coordinate = get_board_dimensions(board)

    horizontal_border = "+" + ("---+" * (max_x_coordinate + 1))

    print(horizontal_border)  # Top border of each cell
    for y in range(max_y_coordinate + 1):
        for x in range(max_x_coordinate + 1):
            if x == 0:
                print("|", end="")
            else:
                print(" ", end="")

            grid_symbol = " "
            if isinstance(board[(x, y)], dict):
                grid_symbol = "!"
            if (x, y) == character_coordinates:
                grid_symbol = "@"
            # Truncate or pad room name to fit in the cell
            # display_name = (grid_symbol[:15] + '..') if len(grid_symbol) > 15 else grid_symbol.ljust(17)
            print(f" {grid_symbol} ", end="")
        print("|")  # Right border of the last cell
    print(horizontal_border)  # Bottom border of the last row


def render_current_location(board, character):
    """
    Describe the current location by printing it on the screen

    :param board: a test_game board
    :param character: a test_game character
    :precondition: board is a test_game board generated by the make_board() function in this module
    :precondition: character is a test_game character generated by the make_character() function in this module
    :postcondition: a message is printed, no data is modified and no value is returned
    :return: None
    """
    character_coordinates = (character["X-coordinate"], character["Y-coordinate"])
    scenario = board[character_coordinates]
    if there_is_a_npc := check_for_npc(scenario):
        return
    render_ascii_map(board, character_coordinates)
    render_text.print_text_line(scenario)


def make_board(level_info):
    """
    Make a test_game board with specified numbers of rows and columns with scenarios associated with each coordinates

    :param rows: number of rows on the board
    :param columns: number of columns on the board
    :precondition: rows is a positive integer
    :precondition: columns is a positive integer
    :postcondition: Create a test_game board based on the inputted rows and columns, and predefined scenarios
    :return: a dictionary with tuples as keys representing coordinates, and strings as values representing scenarios
    """
    # NOTE: will take in a map_elements dictionary to render a map dictionary with key: Coordinates, value: (place or npc, description or npc)
    # if rows < 2 or columns < 2:
    #     return None
    rows = level_info["rows"]
    columns = level_info["columns"]
    scenarios = level_info["area_descriptions"]
    npcs = level_info["npcs"]

    coordinates = []
    for column in range(columns):
        coordinates.extend((column, row) for row in range(rows))
    board = {
        coordinate: scenarios[random.randint(0, len(scenarios) - 1)]
        for coordinate in coordinates
    }
    for npc in npcs:
        npc_coordinates = tuple(npc["coordinates"])
        board[npc_coordinates] = npc

    return board


def validate_move(rows, columns, character, direction):
    """
    Determine whether a move is valid based on whether the move will put the character out of bounds

    :param rows: number of rows on the board
    :param columns: number of columns on the board
    :param character: a test_game character
    :param direction: a integer between 1 and 4 representing a direction
    :precondition: rows is a positive integer larger or equal to 2
    :precondition: columns is a positive integer larger or equal to 2
    :precondition: character is a character generated by the make_character(), character is alive, goal is not reached
    :precondition: direction is an integer between 1 and 4
    :return: a Boolean value of True if character's move is valid, True if it put character out of bounds
    >>> validate_move(3, 3, {"X-coordinate": 2, "Y-coordinate": 0, "Essence": 3}, 1)
    False
    >>> validate_move(3, 3, {"X-coordinate": 2, "Y-coordinate": 0, "Essence": 3}, 2)
    True
    """
    if direction == "W":
        boundary = rows
        coordinate = character["Y-coordinate"] - 1
    elif direction == "S":
        boundary = rows
        coordinate = character["Y-coordinate"] + 1
    elif direction == "D":
        boundary = columns
        coordinate = character["X-coordinate"] + 1
    else:
        boundary = columns
        coordinate = character["X-coordinate"] - 1

    return 0 <= coordinate < boundary


def check_for_npc(scenario):
    # HACK: need fix
    if isinstance(scenario, dict):
        render_dialogue.play_dialogues_from_file(scenario["dialogue_file_path"])
        return True
    return False
