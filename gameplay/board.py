"""
ADD A DOCSTRING
"""
import random

import narrative.dialogue
from gameplay import render_text


def get_board_dimensions(board):
    max_x_coordinate = max(coord[0] for coord in board.keys())
    max_y_coordinate = max(coord[1] for coord in board.keys())
    return max_x_coordinate, max_y_coordinate


def render_ascii_map(board, character_coordinates):
    max_x_coordinate, max_y_coordinate = get_board_dimensions(board)

    horizontal_border = "+" + ("---+" * (max_x_coordinate + 1))
    print(horizontal_border)  # Top border of each cell
    for y in range(max_y_coordinate + 1):
        for x in range(max_x_coordinate + 1):
            print("|" if x == 0 else " ", end="")
            grid_symbol = "!" if isinstance(board[(x, y)], dict) else "@" if (x, y) == character_coordinates else " "
            print(f" {grid_symbol} ", end="")
        print("|")  # Right border of the last cell
    print(horizontal_border)  # Bottom border of the last row


def render_current_location(board, character):
    """
    Describe the current location by printing it on the screen

    :param board: a test_game board
    :param character: a test_game character
    :precondition: board is a test_game board generated by the make_board() function in this module
    :precondition: character is a test_game character generated by the make_character() function in this module
    :postcondition: a message is printed, no data is modified and no value is returned
    :return: None
    """
    character_coordinates = (character["X-coordinate"], character["Y-coordinate"])
    scenario = board[character_coordinates]

    play_dialogues_if_scenario_is_npc(scenario)
    render_ascii_map(board, character_coordinates)
    render_text.print_text_line(scenario)


def make_board(level_info):
    rows = level_info["rows"]
    columns = level_info["columns"]
    scenarios = level_info["area_descriptions"]
    npcs = level_info["npcs"]

    board = {
        (col, row): scenarios[random.randint(0, len(scenarios) - 1)]
        for col in range(columns) for row in range(rows)
    }
    board |= {tuple(npc["coordinates"]): npc for npc in npcs}

    return board


def validate_move(rows, columns, character, direction):
    """
    Determine whether a move is valid based on whether the move will put the character out of bounds

    :param rows: number of rows on the board
    :param columns: number of columns on the board
    :param character: a test_game character
    :param direction: a string representing a direction ("W", "S", "D", "A")
    :precondition: rows is a positive integer larger or equal to 2
    :precondition: columns is a positive integer larger or equal to 2
    :precondition: character is a character generated by the make_character(), character is alive, goal is not reached
    :precondition: direction is one of the strings "W", "S", "D", "A"
    :return: a Boolean value of True if character's move is valid, False if it puts character out of bounds
    >>> validate_move(3, 3, {"X-coordinate": 2, "Y-coordinate": 0, "Essence": 3}, "W")
    False
    >>> validate_move(3, 3, {"X-coordinate": 2, "Y-coordinate": 0, "Essence": 3}, "S")
    True
    """
    direction_map = {
        "W": (0, -1, rows),
        "S": (0, 1, rows),
        "D": (1, 0, columns),
        "A": (-1, 0, columns)
    }
    dx, dy, boundary = direction_map[direction]
    x, y = character["X-coordinate"] + dx, character["Y-coordinate"] + dy

    return 0 <= x < columns and 0 <= y < rows


def play_dialogues_if_scenario_is_npc(scenario):
    if isinstance(scenario, dict):
        narrative.dialogue.play_dialogues_from_file(scenario["dialogue_file_path"])
