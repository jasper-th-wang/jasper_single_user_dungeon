"""
Jasper Wang
A01362031
"""
import json
import random

# TODO: modify character docstrings in different functions according to new stats schemes
from pprint import pprint

from dialogues import play_dialogues_from_file, print_text_line


# WARNING: sourcing test file for now
def opening_sequence():
    play_dialogues_from_file("./tests/opening_test.yarn")


# HACK: mock function
def mock_scenario_descriptions():
    """
    Produce a list of predefined scenario descriptions for the game board

    :return: a list containing strings representing scenario descriptions
    """
    return [
        "The Server Room Labyrinth",
        "The Library of Obsolete Languages",
        "The Cafeteria of Constant Cravings",
        "The Printer Paper Jam Dungeon",
        "The WiFi Woods",
        "The Echo Hall of Helpdesk Calls",
        "The Lost USB Mines",
        "The Classroom of Endless Lectures",
        "The Firewall Fortress",
        "The Recursive Room",
    ]


def get_board_dimensions(board):
    max_x_coordinate = max(coord[0] for coord in board.keys())
    max_y_coordinate = max(coord[1] for coord in board.keys())
    return max_x_coordinate, max_y_coordinate


def render_ascii_map(board, character_coordinates):
    max_x_coordinate, max_y_coordinate = get_board_dimensions(board)

    horizontal_border = "+" + ("---+" * (max_x_coordinate + 1))

    print(horizontal_border)  # Top border of each cell
    for y in range(max_y_coordinate + 1):
        for x in range(max_x_coordinate + 1):
            if x == 0:
                print("|", end="")
            else:
                print(" ", end="")

            grid_symbol = " "
            if isinstance(board[(x, y)], dict):
                grid_symbol = "!"
            if (x, y) == character_coordinates:
                grid_symbol = "@"
            # Truncate or pad room name to fit in the cell
            # display_name = (grid_symbol[:15] + '..') if len(grid_symbol) > 15 else grid_symbol.ljust(17)
            print(f" {grid_symbol} ", end="")
        print("|")  # Right border of the last cell
    print(horizontal_border)  # Bottom border of the last row


# TODO: change docstrings
def render_current_location(board, character):
    """
    Describe the current location by printing it on the screen

    :param board: a game board
    :param character: a game character
    :precondition: board is a game board generated by the make_board() function in this module
    :precondition: character is a game character generated by the make_character() function in this module
    :postcondition: a message is printed, no data is modified and no value is returned
    :return: None
    """
    character_coordinates = (character["X-coordinate"], character["Y-coordinate"])
    scenario = board[character_coordinates]
    # HACK: need fix
    if isinstance(scenario, dict):
        play_dialogues_from_file(scenario["dialogue_file_path"])

    render_ascii_map(board, character_coordinates)
    print_text_line(scenario)


def make_board(level_info):
    """
    Make a game board with specified numbers of rows and columns with scenarios associated with each coordinates

    :param rows: number of rows on the board
    :param columns: number of columns on the board
    :precondition: rows is a positive integer
    :precondition: columns is a positive integer
    :postcondition: Create a game board based on the inputted rows and columns, and predefined scenarios
    :return: a dictionary with tuples as keys representing coordinates, and strings as values representing scenarios
    """
    # NOTE: will take in a map_elements dictionary to render a map dictionary with key: Coordinates, value: (place or npc, description or npc)
    # if rows < 2 or columns < 2:
    #     return None
    rows = level_info["rows"]
    columns = level_info["columns"]
    scenarios = level_info["area_descriptions"]
    npcs = level_info["npcs"]

    coordinates = []
    for column in range(columns):
        for row in range(rows):
            coordinates.append((column, row))

    board = {}
    for coordinate in coordinates:
        board[coordinate] = scenarios[random.randint(0, len(scenarios) - 1)]

    for npc in npcs:
        npc_coordinates = tuple(npc["coordinates"])
        board[npc_coordinates] = npc

    return board


def make_character():
    """
    Create a character with 5 HP, located at (0, 0) on the board

    :postcondition: create a game character
    :return: a dictionary representing a character with their X and Y coordinates, and their health point
    >>> make_character()
    {'X-coordinate': 0, 'Y-coordinate': 0, 'Essence': 5, 'Wisdom': 5}
    """
    return {
        "X-coordinate": 0,
        "Y-coordinate": 0,
        "Essence": 100,
        "Max Essence": 100,
        "Wisdom": 5,
        "Anger": 5,
        "Quest": None,
    }


def display_stats(character):
    print(f"Current Quest: {character['Quest']}")
    print("+-------------------+")
    print("|    Player Stats   |")
    print("+-------------------+")
    print(f"| Essence: {character['Essence']}/{character['Max Essence']} |")
    print(f"| Wisdom: {character['Wisdom']}        |")
    print("+-------------------+")
    print("| Actions:          |")
    print("| W - Go North      |")
    print("| A - Go West       |")
    print("| S - Go South      |")
    print("| D - Go East       |")
    print("| ! - See Stats     |")
    print("+-------------------+")


# TODO: add displaying character functionality, change docstring
def process_users_action(character):
    """
    Print a prompt to ask for the direction the user wish to move towards

    :postcondition: print a prompt to ask for user input, no data is modified
    :return: an integer representing the user's inputted direction
    """
    AVAILABLE_ACTIONS = "WASDwasd!"

    while True:
        user_choice = input(
            "What would you like to do? (Type ! to see stats and available actions.): "
        )

        if len(user_choice) != 1 or user_choice not in AVAILABLE_ACTIONS:
            print(
                f"Invalid entry, please enter one of the following letters or characters: {', '.join('WASD!')}"
            )
            continue

        if user_choice == "!":
            display_stats(character)
        else:
            return user_choice.upper()


# TODO: Modify control scheme to WASD instead, change docstrings
def validate_move(rows, columns, character, direction):
    """
    Determine whether a move is valid based on whether the move will put the character out of bounds

    :param rows: number of rows on the board
    :param columns: number of columns on the board
    :param character: a game character
    :param direction: a integer between 1 and 4 representing a direction
    :precondition: rows is a positive integer larger or equal to 2
    :precondition: columns is a positive integer larger or equal to 2
    :precondition: character is a character generated by the make_character(), character is alive, goal is not reached
    :precondition: direction is an integer between 1 and 4
    :return: a Boolean value of True if character's move is valid, True if it put character out of bounds
    >>> validate_move(3, 3, {"X-coordinate": 2, "Y-coordinate": 0, "Essence": 3}, 1)
    False
    >>> validate_move(3, 3, {"X-coordinate": 2, "Y-coordinate": 0, "Essence": 3}, 2)
    True
    """
    if direction == "W":
        boundary = rows
        coordinate = character["Y-coordinate"] - 1
    elif direction == "S":
        boundary = rows
        coordinate = character["Y-coordinate"] + 1
    elif direction == "D":
        boundary = columns
        coordinate = character["X-coordinate"] + 1
    else:
        boundary = columns
        coordinate = character["X-coordinate"] - 1

    if 0 <= coordinate < boundary:
        return True

    return False


# TODO: Modify control scheme to WASD instead, change docstrings
def move_character(character, direction):
    """
    Move character's coordinates according to specified direction

    :param character: a game character
    :param direction: an integer between 1 and 4 representing a direction
    :precondition: character is a game character generated by the make_character() function in this module
    :precondition: direction is an integer between 1 and 4
    :postcondition: change the character's X or Y coordinate according to direction
    :return: None
    >>> character_demo = {"X-coordinate": 2, "Y-coordinate": 0, "Essence": 3}
    >>> move_character(character_demo, 2)
    >>> character_demo['Y-coordinate'] == 1
    True
    >>> character_demo = {"X-coordinate": 2, "Y-coordinate": 3, "Essence": 3}
    >>> move_character(character_demo, 4)
    >>> character_demo['X-coordinate'] == 1
    True
    """
    if direction == "W":
        character["Y-coordinate"] -= 1
    elif direction == "S":
        character["Y-coordinate"] += 1
    elif direction == "D":
        character["X-coordinate"] += 1
    else:
        character["X-coordinate"] -= 1


def check_for_foes():
    """
    Determine whether a foe is present

    :postcondition: determine if a foe is present by comparing equality between 0 with generated random integer
    :return: a Boolean value of True if foe is present, False otherwise
    """
    random_number = random.randint(0, 3)
    if random_number == 0:
        return True

    return False


# TODO: Change docstrings
def guessing_game(character):
    """
    Start a game number guessing game where user has to guess the randomly generated number between 1 and 5

    :param character: a game character
    :precondition: character is a game character generated by the make_character() function in this module
    :postcondition: 1 HP is deducted from character if user guesses incorrectly, no data is modified otherwise
    :return: None
    """
    print_text_line("!>>> !!! ALERT: MONSTER ENCOUNTER !!! <<<")
    # with K as kill
    # if user use guess: they gain wisdom
    # if user use kill, they gain anger

    # if character wisdom is high, range becomes lower
    lower = 1
    upper = 5

    if character["Wisdom"] > 30:
        upper = 3

    secret_number = random.randint(lower, upper)
    guess = input(
        f"Enter a number between {lower} and {upper} inclusive to deterred the monster, or type 'K' to kill the monster: "
    )

    if guess == "K":
        print_text_line(
            "You killed the monster ruthlessly. Though you are unharmed, you feel an anger inside brewing."
        )
        print_text_line("!You gained 5 Anger")
        character["Anger"] += 5
        return

    while not (guess.isdigit() and int(guess) in range(1, upper + 1)):
        print_text_line(
            f"!Invalid entry, please enter a number between {lower} and {upper} inclusive: "
        )
        guess = input()

    if int(guess) == secret_number:
        print_text_line("You succesfully deterred the monster!")
        print_text_line("$You gained 5 Wisdom!")
        character["Wisdom"] += 5
    else:
        character["Essence"] -= 5
        print_text_line(f"You failed, the monster attacked you and ran away.")
        print_text_line("!You just lost 5 Essence Point")


def check_if_goal_attained(character):
    """
    Determine whether character has reached the goal coordinate

    :param rows: number of rows on the board
    :param columns: number of columns on the board
    :param character: a game character
    :precondition: rows is a positive integer larger than 2
    :precondition: columns is a positive integer larger than 2
    :precondition: character is a game character generated by the make_character() function, and character is alive
    :postcondition: determine if character has reached the bottom right most coordinate of the board
    :return: a Boolean value of True if character has reached the goal, False otherwise
    >>> check_if_goal_attained(4, 4, {"X-coordinate": 3, "Y-coordinate": 3, "Essence": 3})
    True
    >>> check_if_goal_attained(4, 4, {"X-coordinate": 1, "Y-coordinate": 2, "Essence": 1})
    False
    """
    # TODO: Implement so that it will check character's Quest property, if "complete" then goal attained
    # if (
    #     character["X-coordinate"] == rows - 1
    #     and character["Y-coordinate"] == columns - 1
    # ):
    #     return True
    if character["Quest"] == "Complete":
        return True

    return False


def is_alive(character):
    """
    Check if character is alive

    :param character: a game character
    :precondition: character is a game character generated by the make_character() function in this module
    :return: a Boolean value of True if character's current HP is higher than 0, False otherwise
    >>> character_demo = {"X-coordinate": 2, "Y-coordinate": 0, "Essence": 3}
    >>> is_alive(character_demo)
    True
    >>> character_demo = {"X-coordinate": 1, "Y-coordinate": 1, "Essence": 0}
    >>> is_alive(character_demo)
    False
    """
    if character["Essence"] == 0:
        return False
    return True


def get_game_level_info(level):
    with open(f"./levels/level{level}.json", "r") as input_object:
        level_info = json.load(input_object)

    # pprint(level_info)
    return level_info


# TODO: modify docstrings
def play_game_level(level, character):
    """
    Initialize the game

    :return: None
    """
    # helper: read game json file:
    level_info = get_game_level_info(level)

    rows = level_info["rows"]
    columns = level_info["columns"]

    board = make_board(level_info)
    achieved_goal = False

    print_text_line(level_info.get("entrance_description", ""))

    while is_alive(character) and not achieved_goal:
        render_current_location(board, character)
        direction = process_users_action(character)
        valid_move = validate_move(rows, columns, character, direction)
        if valid_move:
            move_character(character, direction)
            # display_current_location(board, character)
            there_is_a_challenger = check_for_foes()
            if there_is_a_challenger:
                guessing_game(character)
            achieved_goal = check_if_goal_attained(character)
        else:
            color_flag = "!"
            print_text_line(f"{color_flag}You cannot go here!")

    if not is_alive(character):
        print("Sorry, you died.")
        return
    else:
        print("Congrats! You reached the end!")
        # TODO: character = STAT BOOST HELPER(character)
        return character


def game():
    MAX_LEVEL = 3
    opening_sequence()
    character = make_character()
    for level in range(1, MAX_LEVEL + 1):
        character = play_game_level(level, character)
        if character == None:
            return
    pass


def main():
    game()


def test():
    # direction = process_users_action(
    #     {
    #         "X-coordinate": 0,
    #         "Y-coordinate": 0,
    #         "Essence": 100,
    #         "Max Essence": 100,
    #         "Wisdom": 5,
    #     }
    # )
    # print(direction)
    # get_game_level_info(1)
    test_character = make_character()
    # test_board2 = make_board(5, 5)
    # test_board = {
    #     (0, 0): "The Server Room Labyrinth",
    #     (0, 1): "The Echo Hall of Helpdesk Calls",
    #     (0, 2): "The Printer Paper Jam Dungeon",
    #     (1, 0): "The Recursive Room",
    #     (1, 1): "The Library of Obsolete Languages",
    #     (1, 2): "The Cafeteria of Constant Cravings",
    # }
    # render_ascii_map(test_board2, (3, 2))
    # display_current_location(test_board2, test_character)
    # test_level = get_game_level_info(1)
    # test_board3 = make_board(test_level)
    # display_current_location(test_board3, test_character)
    # print(test_board3)
    # play_game_level(1, test_character)


# test()

if __name__ == "__main__":
    main()
    pass
