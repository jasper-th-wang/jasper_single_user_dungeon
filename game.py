"""
Jasper Wang
A01362031
"""
import json
import random

from dialogues import play_dialogues_from_file
from monster import check_for_monsters, play_monster_encounter
from render_text import print_text_line

# TODO: modify character docstrings in different functions according to new stats schemes


# WARNING: sourcing test file for now
def opening_sequence():
    play_dialogues_from_file("./dialogues/opening.txt")


# HACK: mock function
def mock_scenario_descriptions():
    """
    Produce a list of predefined scenario descriptions for the test_game board

    :return: a list containing strings representing scenario descriptions
    """
    return [
        "The Server Room Labyrinth",
        "The Library of Obsolete Languages",
        "The Cafeteria of Constant Cravings",
        "The Printer Paper Jam Dungeon",
        "The WiFi Woods",
        "The Echo Hall of Helpdesk Calls",
        "The Lost USB Mines",
        "The Classroom of Endless Lectures",
        "The Firewall Fortress",
        "The Recursive Room",
    ]


def get_board_dimensions(board):
    max_x_coordinate = max(coord[0] for coord in board.keys())
    max_y_coordinate = max(coord[1] for coord in board.keys())
    return max_x_coordinate, max_y_coordinate


def render_ascii_map(board, character_coordinates):
    max_x_coordinate, max_y_coordinate = get_board_dimensions(board)

    horizontal_border = "+" + ("---+" * (max_x_coordinate + 1))

    print(horizontal_border)  # Top border of each cell
    for y in range(max_y_coordinate + 1):
        for x in range(max_x_coordinate + 1):
            if x == 0:
                print("|", end="")
            else:
                print(" ", end="")

            grid_symbol = " "
            if isinstance(board[(x, y)], dict):
                grid_symbol = "!"
            if (x, y) == character_coordinates:
                grid_symbol = "@"
            # Truncate or pad room name to fit in the cell
            # display_name = (grid_symbol[:15] + '..') if len(grid_symbol) > 15 else grid_symbol.ljust(17)
            print(f" {grid_symbol} ", end="")
        print("|")  # Right border of the last cell
    print(horizontal_border)  # Bottom border of the last row


# TODO: change docstrings
def render_current_location(board, character):
    """
    Describe the current location by printing it on the screen

    :param board: a test_game board
    :param character: a test_game character
    :precondition: board is a test_game board generated by the make_board() function in this module
    :precondition: character is a test_game character generated by the make_character() function in this module
    :postcondition: a message is printed, no data is modified and no value is returned
    :return: None
    """
    character_coordinates = (character["X-coordinate"], character["Y-coordinate"])
    scenario = board[character_coordinates]
    # HACK: need fix
    if isinstance(scenario, dict):
        play_dialogues_from_file(scenario["dialogue_file_path"])

    render_ascii_map(board, character_coordinates)
    print_text_line(scenario)


def make_board(level_info):
    """
    Make a test_game board with specified numbers of rows and columns with scenarios associated with each coordinates

    :param rows: number of rows on the board
    :param columns: number of columns on the board
    :precondition: rows is a positive integer
    :precondition: columns is a positive integer
    :postcondition: Create a test_game board based on the inputted rows and columns, and predefined scenarios
    :return: a dictionary with tuples as keys representing coordinates, and strings as values representing scenarios
    """
    # NOTE: will take in a map_elements dictionary to render a map dictionary with key: Coordinates, value: (place or npc, description or npc)
    # if rows < 2 or columns < 2:
    #     return None
    rows = level_info["rows"]
    columns = level_info["columns"]
    scenarios = level_info["area_descriptions"]
    npcs = level_info["npcs"]

    coordinates = []
    for column in range(columns):
        for row in range(rows):
            coordinates.append((column, row))

    board = {}
    for coordinate in coordinates:
        board[coordinate] = scenarios[random.randint(0, len(scenarios) - 1)]

    for npc in npcs:
        npc_coordinates = tuple(npc["coordinates"])
        board[npc_coordinates] = npc

    return board


def make_character():
    """
    Create a character with 5 HP, located at (0, 0) on the board

    :postcondition: create a test_game character
    :return: a dictionary representing a character with their X and Y coordinates, and their health point
    >>> make_character()
    {'X-coordinate': 0, 'Y-coordinate': 0, 'Essence': 5, 'Wisdom': 5}
    """
    return {
        "X-coordinate": 0,
        "Y-coordinate": 0,
        "Essence": 100,
        "Max Essence": 100,
        "Wisdom": 5,
        "Fury": 5,
        "Quest": None,
    }


def display_stats(character):
    print(f"Current Quest: {character['Quest']}")
    print("+-------------------+")
    print("|    Player Stats   |")
    print("+-------------------+")
    print(f"| Essence: {character['Essence']}/{character['Max Essence']} |")
    print(f"| Wisdom: {character['Wisdom']}        |")
    print("+-------------------+")
    print("| Actions:          |")
    print("| W - Go North      |")
    print("| A - Go West       |")
    print("| S - Go South      |")
    print("| D - Go East       |")
    print("| ! - See Stats     |")
    print("+-------------------+")


# TODO: add displaying character functionality, change docstring
def process_users_action(character):
    """
    Print a prompt to ask for the direction the user wish to move towards

    :postcondition: print a prompt to ask for user input, no data is modified
    :return: an integer representing the user's inputted direction
    """
    AVAILABLE_ACTIONS = "WASDwasd!"

    while True:
        user_choice = input(
            "What would you like to do? (Type ! to see stats and available actions.): "
        )

        if len(user_choice) != 1 or user_choice not in AVAILABLE_ACTIONS:
            print(
                f"Invalid entry, please enter one of the following letters or characters: {', '.join('WASD!')}"
            )
            continue

        if user_choice == "!":
            display_stats(character)
        else:
            return user_choice.upper()


# TODO: Modify control scheme to WASD instead, change docstrings
def validate_move(rows, columns, character, direction):
    """
    Determine whether a move is valid based on whether the move will put the character out of bounds

    :param rows: number of rows on the board
    :param columns: number of columns on the board
    :param character: a test_game character
    :param direction: a integer between 1 and 4 representing a direction
    :precondition: rows is a positive integer larger or equal to 2
    :precondition: columns is a positive integer larger or equal to 2
    :precondition: character is a character generated by the make_character(), character is alive, goal is not reached
    :precondition: direction is an integer between 1 and 4
    :return: a Boolean value of True if character's move is valid, True if it put character out of bounds
    >>> validate_move(3, 3, {"X-coordinate": 2, "Y-coordinate": 0, "Essence": 3}, 1)
    False
    >>> validate_move(3, 3, {"X-coordinate": 2, "Y-coordinate": 0, "Essence": 3}, 2)
    True
    """
    if direction == "W":
        boundary = rows
        coordinate = character["Y-coordinate"] - 1
    elif direction == "S":
        boundary = rows
        coordinate = character["Y-coordinate"] + 1
    elif direction == "D":
        boundary = columns
        coordinate = character["X-coordinate"] + 1
    else:
        boundary = columns
        coordinate = character["X-coordinate"] - 1

    if 0 <= coordinate < boundary:
        return True

    return False


# TODO: Modify control scheme to WASD instead, change docstrings
def move_character(character, direction):
    """
    Move character's coordinates according to specified direction

    :param character: a test_game character
    :param direction: an integer between 1 and 4 representing a direction
    :precondition: character is a test_game character generated by the make_character() function in this module
    :precondition: direction is an integer between 1 and 4
    :postcondition: change the character's X or Y coordinate according to direction
    :return: None
    >>> character_demo = {"X-coordinate": 2, "Y-coordinate": 0, "Essence": 3}
    >>> move_character(character_demo, 2)
    >>> character_demo['Y-coordinate'] == 1
    True
    >>> character_demo = {"X-coordinate": 2, "Y-coordinate": 3, "Essence": 3}
    >>> move_character(character_demo, 4)
    >>> character_demo['X-coordinate'] == 1
    True
    """
    if direction == "W":
        character["Y-coordinate"] -= 1
    elif direction == "S":
        character["Y-coordinate"] += 1
    elif direction == "D":
        character["X-coordinate"] += 1
    else:
        character["X-coordinate"] -= 1


def check_if_goal_attained(character):
    """
    Determine whether character has reached the goal coordinate

    :param rows: number of rows on the board
    :param columns: number of columns on the board
    :param character: a test_game character
    :precondition: rows is a positive integer larger than 2
    :precondition: columns is a positive integer larger than 2
    :precondition: character is a test_game character generated by the make_character() function, and character is alive
    :postcondition: determine if character has reached the bottom right most coordinate of the board
    :return: a Boolean value of True if character has reached the goal, False otherwise
    >>> check_if_goal_attained(4, 4, {"X-coordinate": 3, "Y-coordinate": 3, "Essence": 3})
    True
    >>> check_if_goal_attained(4, 4, {"X-coordinate": 1, "Y-coordinate": 2, "Essence": 1})
    False
    """
    # TODO: Implement so that it will check character's Quest property, if "complete" then goal attained
    # if (
    #     character["X-coordinate"] == rows - 1
    #     and character["Y-coordinate"] == columns - 1
    # ):
    #     return True
    if character["Quest"] == "Complete":
        return True

    return False


def is_alive(character):
    """
    Check if character is alive

    :param character: a test_game character
    :precondition: character is a test_game character generated by the make_character() function in this module
    :return: a Boolean value of True if character's current HP is higher than 0, False otherwise
    >>> character_demo = {"X-coordinate": 2, "Y-coordinate": 0, "Essence": 3}
    >>> is_alive(character_demo)
    True
    >>> character_demo = {"X-coordinate": 1, "Y-coordinate": 1, "Essence": 0}
    >>> is_alive(character_demo)
    False
    """
    if character["Essence"] == 0:
        return False
    return True


def get_game_level_info(level):
    with open(f"./levels/level{level}.json", "r") as input_object:
        level_info = json.load(input_object)

    # pprint(level_info)
    return level_info


# TODO: modify docstrings
def play_game_level(level, character):
    """
    Initialize the test_game

    :return: None
    """
    # helper: read test_game json file:
    level_info = get_game_level_info(level)

    rows = level_info["rows"]
    columns = level_info["columns"]

    board = make_board(level_info)
    achieved_goal = False

    print_text_line(level_info.get("entrance_description", ""))

    while is_alive(character) and not achieved_goal:
        render_current_location(board, character)
        direction = process_users_action(character)
        valid_move = validate_move(rows, columns, character, direction)
        if valid_move:
            move_character(character, direction)
            # display_current_location(board, character)
            there_is_a_challenger = check_for_monsters()
            if there_is_a_challenger:
                play_monster_encounter(character)
            achieved_goal = check_if_goal_attained(character)
        else:
            color_flag = "!"
            print_text_line(f"{color_flag}You cannot go here!")

    if not is_alive(character):
        print("Sorry, you died.")
        return
    else:
        print("Congrats! You reached the end!")
        # TODO: character = STAT BOOST HELPER(character)
        return character


def game():
    MAX_LEVEL = 3
    opening_sequence()
    character = make_character()
    for level in range(1, MAX_LEVEL + 1):
        character = play_game_level(level, character)
        if character == None:
            return
    pass


def main():
    game()


if __name__ == "__main__":
    main()
    pass
